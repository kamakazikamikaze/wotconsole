#!/bin/env python
from __future__ import print_function
import os
import sys
import openpyxl
from ciscoconfparse import CiscoConfParse
import warnings
import re

try:  # Portability for Python 3, though 2to3 would convert it
    input = raw_input
    xrange = range
except NameError:
    pass

feed_ports_regex = {
    "3560": r"Gi?0/11$|Gi?0/12$",
    "3750": r"Gi?[1-7]/0/[1-4]$",
    "3850": r"Te?[1-7]/1/[1-4]$|Gi?[1-7]/1/[1-4]$",  # Gig OR TenGig
    "4506": r"Te?[1-6]/[1-2]$|Gi?[1-6]/[3-6]$"
}

switch_models = ["3560", "3750", "3850", "4506", "Other"]

cutsheet_dir = "./cutsheets/"

config_dir = "./configs/"

output_dir = "./output/"

template_dir = "./templates/"


def condensify_ports(ports):
    """Turn a collection of ports into a Cisco-formatted range
    Stub.
    Future development plans on altering format depending on "new" switch model.

    Keyword arguments:
    ports -- a list of ports

    Returns:
    condensed -- a string of ports in a Cisco-formatted range
    """
    # TODO: Accept range of ports and convert to human-readable range
    pass


def vlan_extract(oldconfig, newconfig=None):
    """Retrieve all VLANs from the old configuration file
    The user may specifiy pass a CiscoConfParse object if a full config is to be made or omit it if only a list of VLANs is desired.

    Keyword arguments:
    oldconfig -- CiscoConfParse object of existing configuration file
    newconfig -- CiscoConfParse object, representing the "new" config file; defaults to None

    Returns:
    vlans -- a list of all VLANs defined
    """
    vlans = []
    AllVlanObjects = oldconfig.find_objects(r"^vlan \d+")
    for obj in AllVlanObjects:
        vlans.append(obj.text.split()[-1])
        if newconfig:
            newconfig.append_line("!")
            newconfig.append_line(obj.text)
            for child in obj.children:
                newconfig.append_line(child.text)
    if newconfig:
        newconfig.commit()
    return vlans


def add_snooping(newconfig, vlans):
    """Add DHCP snooping commands to new configuration file"""
    newconfig.append_line("!")
    newconfig.append_line("!")
    newconfig.append_line("ip dhcp snooping vlan " + ",".join(vlans))
    newconfig.append_line("no ip dhcp snooping information option")
    newconfig.append_line("ip dhcp snooping")
    newconfig.append_line("vlan internal allocation policy ascending")
    newconfig.commit()


def migrate_ports(oldconfig, newconfig, hostname, switch_type, debug=True):
    """Map and transfer configuration settings of old ports
    Searches for Excel workbooks in the `cutsheer_dir` directory.
    The "cutsheet" files are generated by TurboClerk which are pulled from Netdoc.

    As of May 2016, Carlos Bassett has set a standard for worksheet layouts and file names, as follows:

    The spreadsheets must have each tab nammed from the source switch and the first column *MUST* be the port name.
    Any jack associated to this port must be in the row, otherwise configuration will not be transferred.
    The file with the current port-jack mappings must have the building code in the name, along with "as is".
    The file with the future port-jack mappings must have the building code in the name, along with "to be".
    The file with the future port-jack mappings *MUST* begin listing ports in the third row.

    Note that this function has the potential to break if corresponding jacks are found from a different existing switch.
    A future workaround of loading the switch it is found from has been added as a TODO

    All returned variables are intended for printing out warnings/notices/debugging

    Keyword arguments:
    oldconfig -- CiscoConfParse object of existing configuration file
    newconfig -- CiscoConfParse object, representing the "new" config file
    hostname -- the name of the new switch
    switch_type -- the index of switch_models that represents the "new" switch model

    Returns:
    blades -- the set of detected blade numbers in the stack
    nojacks -- the list of port names on the new switch that do not have a jack associated with it
    newjacks -- the list of port names on the new switch that have jacks associated, but these jacks are not found in any cutsheets for the building
    """
    # TODO: Detect jacks originating from a different source switch and
    # temporarily load their configuration file
    hostnotfound = True
    warnings.simplefilter("ignore")
    # Supervisor blade is not added to spreadsheets
    blades = set()
    nojacks = []
    newjacks = []
    oldhost = oldconfig.find_lines(r"^hostname")[0].split()[1].lower()
    allconfigfiles = [
        x for x in os.listdir(config_dir) if (
            "confg" in x.lower())]
    otherconfigs = {}
    # Filter by building
    filtered_files = [x for x in os.listdir(
        cutsheet_dir) if (x.split()[0].split("-")[0].lower() in hostname.lower())]
    if len(filtered_files) == 0:
        sys.exit("No cutsheets found!")
    jacks = {}
    for file in [x for x in filtered_files if (
            "as-is" in x.lower() or "as is" in x.lower())]:
        wb = openpyxl.load_workbook(cutsheet_dir + file)
        for ws in wb:
            try:
                sheet = ws.title.lower()
                alt = [m.span() for m in re.finditer(r"\d+$", sheet)]
                match = [x for x in allconfigfiles if sheet in x.lower()]
                if not match:
                    match = [
                        x for x in allconfigfiles if alt and sheet[
                            0:alt[0][0]] in x.lower()]
                if match and not sheet in otherconfigs.keys():
                    otherconfigs[sheet] = CiscoConfParse(
                        config_dir + match[0], factory=True)
            except IOError as e:
                if debug:
                    print(e)
            for row in ws.rows:
                for cell in row:
                    # CiscoConfParse cannot accept leading 0"s in port names,
                    # ex. Fa1/0/01. While this is a localized issue of using
                    # Excel"s autofill, we"ll add the courtesy of dropping it
                    # from the port (not module) number ourselves
                    try:
                        portname = row[0].value
                        if not '/' in portname:
                            break  # Ensure the row is for a port
                        indices = [m.span()
                                   for m in re.finditer(r"\d+", portname)]
                        portname = portname[0: indices[0][
                            0]] + "/".join([str(int(portname[num[0]:num[1]])) for num in indices])
                        jacks[int(cell.value)] = {
                            "old port": portname,
                            "old switch": ws.title.lower()
                        }
                    # except Exception as e:
                        # print(e)
                    except (TypeError, ValueError):
                        continue
    for file in [x for x in filtered_files if (
            "to-be" in x.lower() or "to be" in x.lower())]:
        wb = openpyxl.load_workbook(cutsheet_dir + file)
        for ws in wb:
            if not hostname.lower() in ws["A1"].value.lower():
                continue  # This isn"t a worksheet for the switch
            hostnotfound = False
            for row in ws.rows:
                try:
                    portname = row[0].value
                    if not '/' in portname:
                        continue  # Ensure the row is for a port
                    indices = [m.span() for m in re.finditer(r"\d+", portname)]
                    portname = portname[0:indices[0][
                        0]] + "/".join([str(int(portname[num[0]:num[1]])) for num in indices])
                    # This grabs the blade number. re.finditer will look for all digits
                    # and will be stored in 'm'. m.span will give the index numbers for
                    # where the match starts (inclusive) and where it ends (exclusive),
                    # and returns them as tuples. Since the blade is the first number,
                    # we want the first match. We then get the first number from that
                    # tuple since it's the index number of the string. You may be asking,
                    # "wait, aren't the cutsheets configured to only use the first letter
                    # of the port type, e.g. 'F|G|T'?" Yes, that's how it is currently,
                    # but since the cutsheet generator was designed by a student and
                    # edited by students, I have this unwarranted fear of someone changing
                    # 'T' to 'Te', etc. after I am long gone and this is still in use
                    blades.add(
                        int(portname[
                            [m.span()
                             for m in re.finditer(r"\d", portname)][0][0]
                        ])
                    )
                    transferred = False
                    # TODO: Remove `print` statements when `interfaces_for_review`
                    # is completed
                    for cell in row:
                        try:
                            # Does the host match the one from our config?
                            if oldhost in jacks[int(cell.value)]["old switch"]:
                                port = oldconfig.find_interface_objects(
                                    jacks[int(cell.value)]["old port"])
                                newconfig.append_line("!")
                                newconfig.append_line("interface " + portname)
                                for child in port[0].children:
                                    newconfig.append_line(child.text)
                                transferred = True
                                break  # Got the jack, move to next row
                            # If not, try loading it
                            else:
                                host = jacks[int(cell.value)]["old switch"]
                                cfg = otherconfigs[
                                    host] if host in otherconfigs.keys() else None
                                if cfg:
                                    port = cfg.find_interface_objects(
                                        jacks[int(cell.value)]["old port"])
                                    newconfig.append_line("!")
                                    newconfig.append_line(
                                        "interface " + portname)
                                    for child in port[0].children:
                                        newconfig.append_line(child.text)
                                    transferred = True
                                    del cfg
                                    break  # Got the jack, move to next row
                                else:
                                    raise IOError(
                                        'Could not find config for', host)
                        except IOError as e:
                            print(e)
                        except IndexError:
                            print("Could not load configuration for",
                                  jacks[int(cell.value)]["old port"],
                                  "from",
                                  jacks[int(cell.value)]["old switch"])
                        except (ValueError, TypeError):  # Failures for int() cast
                            continue  # Try next cell
                        except KeyError:
                            # We have a valid jack number but it's new
                            nojacks.append(portname)
                            print(
                                "Port",
                                portname,
                                "is connected to a new jack. Please configure this manually.")
                            newconfig.append_line("!")
                            newconfig.append_line("interface " + portname)
                            newconfig.append_line(" %%NEW CONNECTION%%")
                            transferred = True
                            break
                    if not transferred:
                        newjacks.append(portname)
                        print(
                            "Port",
                            portname,
                            "is not connected to a jack and will be shutdown. Please confirm this manually")
                        newconfig.append_line("!")
                        newconfig.append_line("interface " + portname)
                        newconfig.append_line(" shutdown")
                except TypeError:
                    continue
    if hostnotfound:
        raise Exception("No 'To Be' cutsheet found! Exiting...")
    newconfig.commit()
    del otherconfigs
    if switch_models[switch_type] == "4506":
        blades = set(xrange(0, 7))  # Blades CAN be left empty, so there's that
    return blades, nojacks, newjacks


def interfaces_for_review(newconfig):
    """Searches for interfaces on the "new" device with non-standard configs to be reviewed manually.
    Searches for statically set PoE, duplex, operating speed, no defined switchport mode

    Keyword arguments:
    newconfig -- CiscoConfParse object representing the "new" configuration file
    """
    # TODO: Print warnings for ports on the new device that do not have a
    # source jack or have a new one listed
    power = newconfig.find_objects_w_child(r"^interf", r"^ power")
    # print power
    if power:
        print("\nManually review the following Interfaces for Power settings")
        for obj in power:
            print(" ", obj.text)
    duplex = newconfig.find_objects_w_child(r"^interf", r"^ duplex")
    if duplex:
        print("\nManually review the following Interfaces for Duplex settings")
        for obj in duplex:
            print(" ", obj.text)
    speed = newconfig.find_objects_w_child(r"^interf", r"^ speed")
    if speed:
        print("\nManually review the following Interfaces for Speed settings")
        for obj in speed:
            print(" ", obj.text)
    access = newconfig.find_objects_wo_child(
        r"^interf", r"^ switchport mode")
    access = [obj for obj in access if not obj.re_search_children(
        r"^[\s]?shut(down)?$")]
    if access:
        print("\nThese interfaces did not specify Access or Trunk mode and were set to Access by default.\nManually review the following:")
        for obj in access:
            print(" ", obj.text)
        for obj in access:
            obj.append_to_family(" switchport mode access")
    print("")


def add_voice_vlan(voicevlan, newconfig):
    """Add voice VLAN to access ports that do not have it

    Keyword arguments:
    voicevlan -- a VLAN represented as a string or int
    newconfig -- CiscoConfParse object representing the "new" configuration file
    """
    modified = []
    Voice = " switchport voice vlan " + str(voicevlan)  # Cast, just in case
    NewIntfs = newconfig.find_objects_wo_child(
        r"^interf", r"^ switchport mode trunk")
    for obj in NewIntfs:
        if obj.access_vlan != 0:  # testing to see if access port, should probably adjust to search for switchport mode access, but some ports have this explicit and some don"t
            hasVoice = False
            for child in obj.children:
                if "voice" in child.text:
                    hasVoice = True
            if hasVoice == False:
                obj.append_to_family(Voice)
                modified.append(obj.text)
    modified = []
    # TODO: Remove `print` statements when `interfaces_for_review` is completed
    if len(modified) > 0:
        print("The following ports had a Voice VLAN added. Please manually check that this is appropriate:")
        for each in modified:
            print(" ", each)
    newconfig.commit()
    return modified


def trunk_cleanup(newconfig):
    """Remove access mode configuration on trunk ports
    Removes access/voice vlan configs, spanning-tree portfast, and no snmp trap link-status

    Keyword arguments:
    newconfig -- CiscoConfParse object representing the "new" configuration file
    """
    # TODO: Detect and remove VLANs from VLAN ranges
    TrunkInts = newconfig.find_objects_w_child(
        r"^interf", r"^ switchport mode trunk|shutdown")
    for obj in TrunkInts:
        for child in obj.children:
            if r"switchport access" in child.text:
                child.delete()
            elif r"switchport voice" in child.text:
                child.delete()
            elif r"spanning-tree portfast" in child.text:
                child.delete()
            elif r"no snmp" in child.text:
                child.delete()
    newconfig.commit()
    # Now we want to remove from trunk ports VLANs 1,1002,1003,1004,1005
    TrunkInts = newconfig.find_objects_w_child(
        r"^interf", r"^ switchport mode trunk")
    for obj in TrunkInts:
        TrunkLines = obj.re_search_children(r"switchport trunk allowed vlan")
        # obj.delete_children_matching(r"switchport trunk allowed vlan")
        for child in TrunkLines:
            # TrunkVlans = []
            Add = False
            if "add" in child.text.lower():
                Add = True
            TrunkNumbers = set(child.text.split()[-1].split(","))
            NumsToRemove = set(
                ["1", "1002-1005", "1002", "1003", "1004", "1005"])
            TrunkNumbers = list(TrunkNumbers - NumsToRemove)
            if len(TrunkNumbers) > 0:
                if Add:
                    TrunkConfigLine = " switchport trunk allowed vlan add " + \
                        ",".join(TrunkNumbers)
                    obj.replace(
                        r"^ switchport trunk allowed vlan add ",
                        TrunkConfigLine)
                else:
                    TrunkConfigLine = " switchport trunk allowed vlan " + \
                        ",".join(TrunkNumbers)
                    obj.replace(
                        r"^ (?!add)(switchport trunk allowed vlan )",
                        TrunkConfigLine)
                # obj.append_to_family(TrunkConfigLine)
    newconfig.commit()


def remove_mdix_and_dot1q(newconfig):
    """Remove MDIX and dot1q from all interfaces
    Should be run after `trunk_cleanup()`

    Keyword arguments:
    newconfig -- CiscoConfParse object, representing the "new" config file
    """
    MdixInts = newconfig.find_objects("no\smdix\sauto")
    for obj in MdixInts:
        if obj != []:
            obj.delete()
    newconfig.commit()
    Dot1qInts = newconfig.find_objects(
        "switchport\strunk\sencapsulation\sdot1q")
    for obj in Dot1qInts:
        if obj != []:
            obj.delete()
    newconfig.commit()


def access_cleanup(newconfig):
    """Remove trunk configuration for all ports set to access mode

    Keyword arguments:
    oldconfig -- CiscoConfParse object of existing configuration file
    newconfig -- CiscoConfParse object, representing the "new" config file
    """
    AccessInts = newconfig.find_objects_w_child(
        r"^interf", r"^ switchport mode access")
    for obj in AccessInts:
        for child in obj.children:
            if r"switchport trunk" in child.text:
                child.delete()
    newconfig.commit()
    # I found that some configs are missing the "mode access", so I am also
    # applying to any that are missing "switchport mode"
    AccessInts = newconfig.find_objects_wo_child(
        r"^interf", r"^ switchport mode")
    for obj in AccessInts:
        for child in obj.children:
            if r"switchport trunk" in child.text:
                child.delete()
    newconfig.commit()


def extract_management(oldconfig, newconfig):
    """Extract the management VLAN and add it to new config file
    Assuming the target equipment is a layer 2 switch with only one management VLAN,
    the VLAN config is extracted and the option to retain IP information is provided.
    'ip tacacs source-interface <VLAN>' is added but only necessary for a 4506;
    this command will be ignored on all other models.

    Keyword arguments:
    oldconfig -- CiscoConfParse object of existing configuration file
    newconfig -- CiscoConfParse object, representing the "new" config file
    """
    Vlan1 = oldconfig.find_objects(r"^interface Vlan1$")
    for vlan in Vlan1:
        vlan.delete()
    oldconfig.commit()
    VlanInts = oldconfig.find_objects_wo_child(
        r"^interface Vlan", r"^ ip address")
    for vlan in VlanInts:
        newconfig.append_line(vlan.text)
        for child in vlan.children:
            newconfig.append_line(child.text)
        newconfig.append_line("!")
    newconfig.commit()
    # TODO: Prompt user for any additional configuration to include
    ManagementVlan = oldconfig.find_objects_w_child(
        r"^interface Vlan", r"^ ip address")
    # print(ManagementVlan)
    newconfig.append_line("!")
    newconfig.append_line(ManagementVlan[0].text)
    if "n" in input(
            "Will this equipment use the same IP address?[Y|n]: ").lower():
        NewIP = input("Enter new IP address: ")
        NewGateway = input("Enter new Gateway: ")
        NewMask = input("Enter new subnet Mask: ")
        newconfig.append_line(" ip address " + NewIP + " " + NewMask)
        newconfig.append_line(" no ip route-cache")
        newconfig.append_line(" no ip mroute-cache")
        newconfig.append_line("!")
        newconfig.append_line("ip default-gateway " + NewGateway)
        newconfig.append_line("!")
    else:
        for child in ManagementVlan[0].children:
            newconfig.append_line(child.text)
        newconfig.append_line("!")
        DefaultGateway = oldconfig.find_objects(r"^ip default-gateway")
        newconfig.append_line("!")
        newconfig.append_line(DefaultGateway[0].text)
        newconfig.append_line("!")
    # Only the 4506 uses the following line, but it will be ignored on other
    # devices anyways, so we"ll just leave it here
    newconfig.append_line("ip tacacs source-interface " +
                          ManagementVlan[0].text.split()[-1])
    newconfig.commit()


def file_export(outputfile, newconfig):
    """Save current configuration to a file
    Exports to the directory defined by internal/global var 'output_dir'

    Keyword arguments:
    outputfile -- desired file name
    newconfig -- CiscoConfParse object, representing the "new" config file
    """
    try:
        newconfig.save_as(output_dir + outputfile)
        print("\nFile saved as", outputfile)
    except IOError as e:
        print("Unable to save file:")
        print(e)


def setup_feeds(newconfig, switch_type, blades, vlans):
    """Configure feedports
    Allows the user to define as many feedports as desired.
    Checks the validity of the port name as defined by a regex string.

    Keyword arguments:
    newconfig -- CiscoConfParse object, representing the "new" config file
    switch_type -- the representation of the switch model in the form of the switch_models index
    blades -- a set of all blade numbers in the stack
    vlans -- a list of all VLANs transferred to the new configuration file
    """
    if "y" in input(
            "\nWould you like to set up feedports?[y|N]: ").lower():
        try:
            finished = False
            print("When you are finished, type 'no' for the feedport name")
            print("(Use 'T' or 'G' instead of 'Ten' or 'Gig'!)")
            while not finished:
                feedport = input("Feedport name: ").upper()
                if not feedport.lower() == "no":
                    blade = int(feedport[
                        [m.span() for m in re.finditer(r"\d", feedport)][0][0]
                    ])
                    if re.search(feed_ports_regex[switch_models[switch_type]], feedport) and (
                            blade in blades):
                        exists = newconfig.find_objects(
                            r"^interface " + feedport.strip())
                        if len(exists) > 1:
                            print("Uh, your interface matches several others:")
                            for each in exists:
                                print(" ", each.text)
                            print("Abandoning changes...")
                        elif len(exists) == 1:
                            existing = exists[0]
                            print("Interface already exists!")
                            print(existing.text)
                            for line in existing.children:
                                print(line.text)
                            if "y" in input("Overwrite?[y|N]: ").lower():
                                for child in existing.children:
                                    child.delete()
                                newconfig.commit()
                                _setup_feed(newconfig, feedport, switch_type)
                        else:
                            _setup_feed(newconfig, feedport, switch_type)
                    else:
                        print(
                            "That is an invalid port. Either the spelling is wrong or the numbering is out of range!")
                else:
                    finished = True
        except Exception as e:
            print("Exception:", e)


def _setup_feed(newconfig, feedport, switch_type):
    """Create or modify the desired feed port
    Only to be called by the setup_feeds function.
    Prompts for description, will add 'dot1q' for 3560 models
    Puts port into trunk mode, adds all VLANs, adds DHCP snooping trust

    Keyword arguments:
    newconfig -- CiscoConfParse object, representing the "new" config file
    feedport -- the string representing the desired feed name
    switch_type -- the representation of the switch model in the form of the switch_models index
    """
    existing = newconfig.find_objects(r"^interface " + feedport.strip())
    if existing:
        exists = existing[0]
        if "y" in input("Would you like to add a description?[y|N]: ").lower():
            exists.append_to_family(" description " + input("Description: "))
        if switch_models[switch_type] == "3560":
            exists.append_to_family(" switchport trunk encapsultion dot1q")
        exists.append_to_family(" switchport mode trunk")
        exists.append_to_family(
            " switchport trunk allowed vlan " +
            ",".join(vlans))
        exists.append_to_family(" ip dhcp snooping trust")
    # else:
    elif newconfig.has_line_with(r"^hostname"):
        newconfig.insert_after(
            r"^hostname",
            " ip dhcp snooping trust")
        newconfig.insert_after(
            r"^hostname",
            " switchport trunk allowed vlan " +
            ",".join(vlans))
        newconfig.insert_after(
            r"^hostname",
            " switchport mode trunk")
        if switch_models[switch_type] == "3560":
            newconfig.insert_after(
                r"^hostname",
                " switchport trunk encapsultion dot1q")
        if "y" in input("Would you like to add a description?[y|N]: ").lower():
            newconfig.insert_after(
                r"^hostname",
                " description " +
                input("Description: "))
        newconfig.insert_after(
            r"^hostname",
            "interface " + feedport)
        newconfig.insert_after(r"^hostname", "!")
    else:
        newconfig.append_line("!")
        newconfig.append_line("interface " + feedport)
        if "y" in input("Would you like to add a description?[y|N]: ").lower():
            newconfig.append_line(" description " + input("Description: "))
        if switch_models[switch_type] == "3560":
            newconfig.append_line(" switchport trunk encapsultion dot1q")
        newconfig.append_line(" switchport mode trunk")
        newconfig.append_line(
            " switchport trunk allowed vlan " +
            ",".join(vlans))
        newconfig.append_line(" ip dhcp snooping trust")
        newconfig.append_line("!")
    newconfig.commit()


def get_switch_model():
    """Prompt user to select model from compatible list

    Returns the user's input as the internal `switch_models` index
    """
    print("Compatible switch models:")
    for switch in enumerate(switch_models):
        print(" [" + str(switch[0] + 1) + "]", switch[1])
    switch_type = None
    while not switch_type in xrange(1, len(switch_models) + 1):
        switch_type = int(
            input("What switch model are you programming? ")) - 1
    return switch_type


def get_configs():
    """Set the configuration file to pull data from
    Prompts user for file name

    Returns two CiscoConfParse objects: the old config file, and a new config
    """
    directory = sorted([x for x in os.listdir(config_dir) if "confg" in x])
    for item in enumerate(directory):
        print(" [" + str(item[0] + 1) + "]", item[1])
    name = None
    while not name in xrange(1, len(directory) + 1):
        name = int(
            input("Please select the file number of the old config: "))
    filename = directory[name - 1]
    oldconfig = CiscoConfParse(config_dir + filename, factory=True)
    # # The new parser needs a file associated with it, so create a throwaway.
    # # Trying to give it a legit file strangely invokes an error later on...
    newconfig = CiscoConfParse(os.tmpfile(), factory=True)
    return oldconfig, newconfig


def force_user_input(display):
    """Enforce that the user input at least one character

    Keyword arguments:
    display -- the string to display as the input prompt

    Returns user input string
    """
    name = ""
    while len(name) == 0:
        name = input(display)
    return name


def set_voice_vlan(oldconfig):
    """Select and add a voice VLAN to add to access ports

    Keyword arguments:
    oldconfig -- CiscoConfParse object of existing configuration file
    """
    print("Available voice VLANs:")
    vlans = oldconfig.find_objects(r"^vlan 1\d\d$")
    skipvoice = False
    if len(vlans) > 1:
        voicevlan = ""
        while len(voicevlan) == 0:
            for v, num in zip(vlans, xrange(1, len(vlans) + 1)):
                print(" [" + str(num) + "]", v.text.split()
                      [-1], "-", v.children[0].text.split()[1:])
            print(" [0] Skip")
            voicevlan = input("    Enter voice VLAN: ")
            try:
                if int(voicevlan) == 0:
                    skipvoice = True
                    break
                else:
                    voicevlan = vlans[int(voicevlan) - 1].text.split()[-1]
            except:
                voicevlan = ""  # Invalid input
    elif len(vlans) == 1:
        if "n" in input("Only one voice VLAN found: " + vlans[0].text.split(
        )[-1] + " - " + str(vlans[0].children[0].text.split()[1:]) + ". Use this?[Y|n]: ").lower():
            skipvoice = True
        else:
            voicevlan = vlans[0].text.split()[-1]
    else:
        print("No standard voice VLAN detected.")
        skipvoice = True
    if not skipvoice:
        add_voice_vlan(voicevlan, newconfig)


# This module is designed to allow running it from a CLI or importing it and calling
# its functions, however it revolves mostly around Layer 2 device configuration
if __name__ == "__main__":
    oldconfig, newconfig = get_configs()
    switch_type = get_switch_model()
    hostname = force_user_input("Enter hostname of new switch: ").upper()
    outputfile = force_user_input("Enter output file name: ")
    createconfig = (not "n" in input(
        "Generate full config file?[Y|n]: ").lower())
    if createconfig:
        baseconfig = ".txt"
        if (switch_type == len(switch_models) - 1):
            baseconfig = "baseconfig.txt"
        else:
            baseconfig = switch_models[switch_type] + "base.txt"
        newconfig.append_line("!")
        newconfig.append_line("hostname " + hostname)
        newconfig.append_line("!")
        newconfig.commit()
    blades, nojacks, newjacks = migrate_ports(
        oldconfig, newconfig, hostname, switch_type)
    # Add ip dhcp snooping later: adding it immediately after interfaces
    # causes a bug if trying to use file as startup-config
    if createconfig:
        vlans = vlan_extract(oldconfig, newconfig)
    else:
        vlans = vlan_extract(oldconfig)
    setup_feeds(newconfig, switch_type, blades, vlans)

    # if createconfig:
    interfaces_for_review(newconfig)
    set_voice_vlan(oldconfig)
    trunk_cleanup(newconfig)
    # This must be run AFTER trunk_cleanup()
    if not switch_models[switch_type] == "3560":
        remove_mdix_and_dot1q(newconfig)

    if createconfig:
        extract_management(oldconfig, newconfig)
        add_snooping(newconfig, vlans)
        newconfig.append_line("!")
        with open(template_dir + baseconfig, "r") as b:
            for line in b:
                newconfig.append_line(line.rstrip())
        newconfig.commit()

    file_export(outputfile, newconfig)
